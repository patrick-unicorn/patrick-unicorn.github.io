---
author: "patrick.unicorn"
output:
  html_document:
    css: ../css/main.css
    highlight: null
    theme: null
---

Spring笔记整理
===

**声明：** 所写均为个人阅读所思所想，请批判阅读。

* * *

+ IOC即控制反转，其更加直接易懂的名字是Matin Fowler提出的“DI即依赖注入”。就是将**客户类**对**某一接口实现类**的**依赖**，交由第三方的容器（IOC/DI)去控制。

+ 依赖注入类型：

1. 构造函数注入
2. 属性注入
3. 接口注入（不提倡）

+ 类装载器就是寻找类的字节码并构造出类再JVM内部表示的对象组件。

+ 装载类的步骤：

1. 查找和导入class文件
2. 检验class文件，给类的静态变量分派空间，将符号引用转变为直接引用。
3. 对类的初始化变量和代码进行初始化。

+ 类装载器主要有：

1. 根装载器 C++实现，不是ClassLoader的子类，Java中不可见，主要转载JRE核心类库。
2. ExtClassLoader  是ClassLoader的子类，负责装在JRE中ext目录下的类。
3. AppClassLoader 是ClassLoader的子类，负责装在classpath下的类。

它们之间存在父子关系，即**根装载器 --> ExtClassLoader --> AppClassLoader**. 

+ JVM装载类采用“全盘委托制”：除非显示引用别的装载器，否则，该类及其所依赖和引用的类也由该装载器载入。并且，先委托父装载器进行查找载入，逐级向下由各级装载器尝试装入类，最终到当前装载器。

如此设定主要是出于安全原因。试想如果有人恶意编写一个基础类（java.lang.String）,如果采用这种机制，就会避免被恶意载入。

<blockquote>
常见的java.lang.NoSuchMethodError错误的根源就在类装载机制：
1. 相应的类没有装载
2. 同时有多个版本的类，类装载器正好装载的那个版本类不存在此方法。
</blockquote>

+ ClassLoader是java.lang中的抽象类，其主要方法如下：

1. loadClass(String name, boolean resolve) name必须是类的完全限定名。如果只是确定类是否存在，或者只需要找到类的超类等，就不需要对类进行解析，可以将resolve设置为false.

2. findeSystemClass(String nameg) 该方法是JVM默认的装载机制。

3. defineClass(String name, byte[] b, int len, int off) 将类文件二进制数组转换为JVM中的java.lang.Class对象。

4. findLoadedClass(String name) 判断是否已装载某类。如果已装载，返回class对象；否者，返回null.

5. getParent() 获取父装载器，因为根装载器无法获得，因此会返回null.

+ 每个类在JVM中都有一个java.lang.Class对象，它提供基本的类结构元信息。所有的基本类型，甚至void都存在一个class对象，该对象在装载类时有JVM创建。

+ JDK提供的资源访问器是：java.net.URL和File。它们并不支持从类路径或WEB上下文中获取资源。因此，Spring设计了Resource接口。Spring使用其装载所有的资源。

+ Resource接口的实现类：

1. ByteArrayResource
2. ClasspathResource
3. FileSystemResource
4. InputStreamResource
5. ServletContextResource
6. UrlResource

+ 资源路径表示：

|名称|前缀|资源类|
|类路径|classpath:|ClasspathResource|
|网络路径|ftp: http:|UrlResource|
|文件|file:|FileSystemResource|

<blockquote>
三个独立的模块jar包，均有com.unicorn包，该包下分别有如下配置文件：

|模块|配置文件|
|--|--|
|1|application-data.xml|
|2|application-service.xml|
|3|application.xml|

如果使用**classpath:com/unicorn/application\*.xml**，只会加载某一个包中的配置文件。

如果使用**classpath\*:com/unicorn/application\*.xml**，三个配置文件均会加载。 
</blockquote>

+ Ant风格资源地址三种匹配符：

1. `?`: 匹配一个字符
2. `*`: 匹配任意个字符
3. `**`: 匹配多层路径

+ BeanFactory是Spring的基础设施，面向Spring本身；ApplicationContext面向所有Spring应用开发者。

+ Spring中资源加载的基本类是`PathMatchingResourcePatternResolver`。

+ ApplicationContext主要的实现类是：`ClassPathXmlApplicationContext`和`FileSystemApplicationContext`。

+ ApplicationContext除了实现BeanFactory相关接口（类）外，还实现了如下接口以扩充功能：

1. ApplicationEventPublisher 发布应用上下文事件，如容器启动、关闭事件。实现`ApplicationListener`接口的Bean可以接收到容器事件。
2. MessageResource 提供i18n国际化消息访问。
3. ResourcePatternResolver 提供类似`PathMatchingResoucePatternResolver`的资源加载功能。
4. LifeCycle 该接口提供start和stop方法，主要用于异步控制。ApplicationContext会将start和stop的信息传递给容器中所有实现了该接口的bean。

+ WebApplicationContext是专为WEB容器准备的，允许从Web根目录的路径中装载配置文件。其被作为属性（建为`ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE`）放置在ServletContext中，可以通过WebApplicationContextUtils获取。WebApplicationContext也保持了对ServletContext的引用。

```
(WebApplicationContext) servletContext.getAttribute(
    WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
```

+ 非WEB应用下，只有Singleton和Prototype两种Bean作用域。而WebApplicationContext中添加了三个新的Bean作用域：Request、Session、Global Session。

+ WebApplicationContext的初始化需要ServletContext，因此，spring提供了两个类支持：

1. org.springframework.web.context.ContextLoaderServlet
2. org.springframework.web.context.ContextLoaderListener

将其配置在WEB容器的web.xml即可。

+ 如果要使用log4j引擎，可以将log4j的配置文件放在WEB-INF/class下，如果需要放到其他位置，那么需要使用spring提供的支持类：

1. Log4jConfigServlet
2. Log4jConfigListener

+ 需要注意的是，log4j需要保证在WebApplicationContext之前初始化，因此，如果使用servlet，则Log4jConfigServlet要先于ContextLoaderServlet启动（配置startup）。如果使用listener，则Log4jConfigListener必须配置在ContextLoaderListener之前。

+ 使用HierarchicalBeanFactory，可以建立父子关联的容器体系。子容器可以访问父容器的Bean，反之，不可。子容器中可以存在与父容器id相同的bean。

+ 父子容器的一个典型应用就是SpringMVC。在SpringMVC中，展现出Bean存在于子容器中，而业务层和持久层的Bean位于父容器中，这样，就隔离了Bean。

+ Spring中的Bean生命周期有两个方面：

1. Bean的作用域
2. 实例化Bean时所经历的一系列阶段

+ Spring Bean的生命周期：

![spring bean生命周期](../images/content/spring-notes-01.png)

其生命周期管理方法分为三个层面

1. Bean自身方法【绿色】 
2. Bean级接口实现【黄色】 处理个性

```
- BeanNameAware
- BeanFactoryAware
- ApplicationContextAware
- InitializingBean
- DisposableBean。
```

这类接口相当于将Bean与Spring框架紧耦合了，因此，应当尽可能的少用，可采取其他替代方式。

3. 容器级接口实现【红色】 处理共性

```
- InstantiationAwareBeanPostProcessor
- BeanPostProcessor
- BeanFactoryPostProcessor(实现类如：PropertyPlaceholderConfigurer等)
```

可以同时实现多个容器级接口，但必须同时实现org.springframework.core.Ordered接口。

+ Bean的id必须唯一，并且符合xml命名规则。

+ Bean的name可以有多个，使用`,`分隔。

+ 注入方式

1. 属性注入
2. 构造函数注入
3. 工厂方法注入

```
<bean factory-bean="" factory-method="" />
```

+ ![CDATA[....]]的作用类似于转义，即将其中的字符全部当做普通字符处理，避免破坏XML格式。

+ 通过ref元素可以引用其他bean，其包含三个属性：

```
<bean ...>
    <property>
        <ref bean="<id>" />
    </property>
</bean>

// 被引用的bean必须在当前配置文件
<bean ...>
    <property>
        <ref local="<id>" />
    </property>
</bean>

// 被引用的bean必须在父容器
<bean ...>
    <property>
        <ref bean="<id>" />
    </property>
</bean>
```

+ 内部Bean

```
<bean ...>
    <property ...>
        // 内部Bean
        <bean ...>
            <property ... />
            <property ...
        </bean>
    </property>
</bean>
```

内部Bean即使声明id、name、scope等，也会被忽略。scope默认是prototype。

+ 设置null值

```
<property><null /></property>
```

+ 设置级联属性

```
<property name="car.name" value="大众" />
或
<property name="car.name">
    <value>大众</value>
</property>
```

+ 引入p空间，是为了简化xml配置。

```
<bean ...>
    <property name="price" value="200" />
    <property name="shop" ref="711Shop" />
</bean>
=>
<bean p:price="200" />
<bean p:shop_ref="711Shop" />
```

+ 集合属性：List、Set、Map、Properties

+ Spring提供了4种自动装配类型：

|自动装配类型|说明|
|--|--|
|byType|根据类型|
|byName|根据类名（非完全限定名）|
|constructor|与byType类似，只不过是针对构造函数注入而言的|
|autodetect|如果bean提供了默认构造函数，则使用byType；否则，使用constructor|

+ 可以通过配置文件声明Bean之间的继承关系，但实际应用中很少用。

```
<bean id="pa" abstract="true"></bean>
<bean id="son" parent="pa"></bean>
```

+ `<idref>`标签主要是用于引用另外一个Bean的**id字面量**。

+ `depend-on`属性可以用于定义当前bean的前置依赖。

```
<bean id="A" depend-on="B,C" />
```

+ `<import resource="" />可以用于将多个配置文件整合到一个配置文件中。这在大型应用中非常有用。

+ 如果要在WEB环境下使用Request、Session、Global Session三个作用域，则需要在web.config中添加配置项：

```
<filter>
    <filter-name>requestContextFilter</filter-name>
    <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>requestContextFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

或者

<listener>
    <listener-class>
        org.springframework.web.context.request.RequestContextListener
    </listener-class>
</listener>
```

+ Gloabal Session作用域类似于Session，但仅限于Porlet应用中。

+ Java只能对接口添加动态代理，如果要给类添加动态代理，需要应用CGlib库。

+ 如果要在singleton或prototype的Bean中引用WEB作用域Bean，那么需要使用AOP。

```
<bean id="A" class="" scope="request">
    <aop:scoped-proxy />
</bean>
<bean>
    <property name="" ref="A" />
</bean>
```