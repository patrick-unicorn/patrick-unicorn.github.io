**声明：** 所写均为个人阅读所思所想，限于知识层次和结构，难免有错误遗漏之处，请批判阅读。探讨可循：<mr.geek.ma@gmail.com>

* * *

读了《图灵的秘密：他的生平、思想及论文解读》，云里雾里半懂不懂，摘抄一些基本思想和概念。另外，读完后我发现这本书和之前研读的Lambda论文关系颇深，对于之前一些模糊的概念有了更深入的理解，也算意料之外的收获。

* * *

+ 斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合，相邻两个数的比值符合黄金分割比率。
+ 通常说网络带宽是5M，是指5M bit，而非5M byte，而下载速度256KB通常是指byte。因此，一个2M的网络下载速度最大为2 * 1024 / 8 = 256 KB.
+ 异或满足可逆，可以使用异或实现数据加密：0001（被加密数） ^ 0011（掩码） = 0010（加密数）；0001 = 0010 ^ 0011（掩码）。
+ 大端排序：低地址（索引）存放高位字节；小端排序：低地址（索引）存放低位字节。TCP网络流统一规定使用大端排序，JVM统一使用大端排序。
+ 取数字N的二进制中的i到j位：mask=00...11...11...00; 结果= N & mask
+ index = value % 16   等价于如下算式：index = (value * N) >>M
    + 16位整数时，N=40503，M=16 - 4（log16）=12
    + 32位整数时，N=2654435769，M=32 - 4 （log16）=28
    + 64位整数时，N=11400714819323198485，M=64 - 4（log16）=60
+ 1 << offset 等价于 2^offset。eg.  1 << 4 == 2^4 == 16
+ 数的概念
    + 正整数就是自然数；
    + 正整数，0，负整数构成整数；
    + 有理数可以表示为两个整数相除形式，包含整数、有限小数、无限循环小数构成有理数；
    + 无理数不能表示为两个整数相除，包含无限不循环小数。
    + 负数的平方根称为虚数；
    + 实数指除虚数外的一切数，也称为**连续统**，因为实数可以看做一条连续直线上的所有点。
    + 实数划分的一个维度：有理数和无理数。
    
+ 代数方程只包含一个变量的方程，其解称为**代数数**，其一般形式如下：

> a<sub>N</sub>x<sup>N</sup> + a<sub>N-1</sub>x<sup>N-1</sup> + ... + a<sub>2</sub>x<sup>2</sup> + a<sub>1</sub>x + a<sub>0</sub> = 0

+ 实数都是代数数么？答案是否定的，除了代数数，还有一部分称为**超越数**。这是实数的另一个维度的分类。我们熟知的π和欧拉数e均是超越数。π是超越数也间接证明了为什么“化圆为方”是不可能的。

> 以π是超越数视角理解**化圆为方**的可行性
> 
> 已知半径为R的圆，假设可以转换为同等面积的边为a正方形，那么，可以得出如下方程：
> R<sup>2</sup>*π = a<sup>2</sup>，如果我们将π看做一个未知量，那么π就是该方程的一个解，即π使一个代数数。这与**π是超越数**相矛盾，因此，得出“化圆为方”不可行。
> 
> 至今为止，很多数已被证明为超越数，但是，仍然没有一种通用的方法来证明一个给定数是否为超越数。

+ 丢番图方程允许包含多个变量。

+ 如果集合中的元素可以和自然数一一对应，那么我们称集合是**可数的**。整数集合，有理数集合，代数数集合均是可数的。实数集合是不可数的。

+ 康托尔提出无穷有两种无穷：可数的无穷和不可数的不穷。即自然数(整数、有理数、代数数等)的无穷和连续统(实数)的无穷。

+ 集合元素的个数称为**基数**，也叫**势**。基数相同的集合称为**等势集合**。
+ 集合的**真子集**是指那些与自身不相同的子集。
+ 有限集合和无限集合的一个巨大不同是：
   + 有限集合的真子集的基数总是小于集合本身的。
   + 无限结合的真子集的基数并不一定小于集合本身的基数，也可能相等，比如自然数的真子集偶数具有与自然数集相同额基数。事实上，自然数集、整数集、有理数集、代数数集的基数均均是相同的。
   
+ 康托尔发现，连续统(实数，即直线上的点)可以和平面上的点，空间中的点可以一一对应，即它们是等势的。
   
+ 康托尔发明了**对角线证明**，这一方法，明确的揭示了**可数性**和**不可数性**。

+ 一个集合的所有子集叫做**幂集**。

+ 康托尔定理：任何集合的元素和其幂集的元素之间**不能**一一对应。其幂集的势大于原集合的
势。

+ 超越数的数量远远多于代数数。

+ 自然数集的基数称为第一**超现数**，连续统(实数集)的技术称为第二**超现数**。注意与超越数区别，两者意义完全不一样。

+ 图灵定义，**可计算数**是指其小数形式可以在有限步骤内计算出来的实数。这里的“步骤”并不是指确定每一数位的实际过程，而是指确定每一数位的**方法**。比如，1/3的小数形式是0.333333..333，很明显它的小数位是无限的，但是存在一个方法(算法)，可以确定它每一个数位(此处每位都是**3**)；对于π的可计算性，可以同理理解。

+ 可计算数是**可数的**。实数是不可数的，因此，显然实数集的势大于可计算数。

+ 代数数都是**可计算的**。超越数中有一部分是可计算的，比如π，欧拉数e等等。

+ 命题逻辑也称为一阶谓词(逻辑或演算)或者“受限的函数演算”，它是指处理所有具有真值的陈述命题。比如：今天**是**晴天、7**是**个素数等等。一阶谓词的说法更加普遍。

+ 一阶谓词逻辑中的常用符号：
    + `v`代表“析取(disjunction)”即“或”。
    + `&`代表“合取(conjunction)”即“且”。有时也用符号\(\land\)。
    + `eq.`代表“等价”。
    + `-`代表“非”。有时也用符号\(\neg\)。
    + `→`代表“蕴含”，`X → Y`读作“X蕴含Y”或者“若X为真，则Y为真”。
    + `~`代表“当且仅当”。`X ~ Y`为真，当且仅当X和Y的真值相同时。`X ~ Y eq. (X → Y)&(Y → X)`。
    + \(\forall\)代表“全称量词”，**(\(\forall\) x)Loves(Pat, x)**表示所有的x都使Loves(Pat, x)为真。有时也用符号Σ。
    + \(\exists\)代表“存在量词”，**(\(\exists\) x)Loves(Pat, x)**表示存在x使得Loves(Pat, x)为真。有时也用符号Π。

> 蕴含不满足交换律和结合律。但是存在如下规则：
>
> + `X → Y` eq. `-Y → -X`    注：其实就是命题和逆否命题的等价关系。
+ `X → Y` eq. `-X v →Y`    
+ `X → Y` eq. `-(X & → -Y)`
+ `X & Y & Z &···& K → X` eq. `X & Y & Z &···& K → Y` eq. `X & Y & Z &···& K → K` eq. ··· ···。即如果蕴含符号的左侧是任意多个命题的与式，那么这些命题中的任何一个都可以放在蕴含符号的右边。

> 全称量词符号和存在量词符号可以如下理解：
>
> A就是all，为避免雷同，倒过来作符号，表示**所有**。E就是exist，反过来做符号表示**存在**，同样是为了避免雷同。

+ (X v Y) & (-X v -Y) 等价于对X和Y求异或。
+ 命题的分类：
    + 永真式(重言式)，如`X v Y v (-X & -Y)`，无论X、Y为何值，该命题永真。
    + 矛盾式，如`X & Y & -X`，无论X、Y为何值，该命题永假。
    + 可满足式，如`X v Y`，命题真假随X、Y变化。

+ 对任意一个命题，都可以通过构建**真值表**来判断其类型。基于这一原因，命题演算(一阶谓词演算)中的命题是**可判定的**。
+ 虽然**真值表**是可以判定命题演算中的命题的。但是由于处理真值表的时间是指数级的，因此，当命题中的命题变量非常多时，需要进行的演算时间会长到难以接受。因此，**解法**比真值表更有价值，可以把命题表示为一些范式，而范式可以是若干个变元构成的析取项的合取，或合取项的析取。
+ 一阶谓词逻辑中的“谓词”很类似“函数”，但它的取值只能是**真或假**，它可以包含多个参数。比如`Loves(x, y)`与命题“x爱上y”相同。
+ 公式中被某个量词(存在量词或全称量词)修饰的变量称为约束变量。反之，称为自由变量。如下的公式中，x是约束变量，而y是自由变量。$$(\forall x)Loves(x, y)$$
+ 同一公式中不能包含相同名称的自由变量和约束变量。
+ 一阶逻辑中不包含任何自由变量的的公式称为**命题**。
+ 约束变量存在作用范围，使用括号表述。如下：$$(\forall x)(Loves(x, y) \land Loves(x, z))$$命题的意思是指“所有的x既爱y也爱z”。
+ 几个量词可以同时使用。如(\(\exists\)x)(\(\forall\)y)Loves(x, y)与(\(\exists\)x)[(\(\forall\)y)Loves(x, y)]表达的意思相同，但是，两个量词的顺序互换后就大不一样了。
+ 当公式中存在一连串的全称量词时，改变其顺序不会导致含义变化。存在一连串量词也是成立的。
+ 对于公式(\(\exists\)x)[F(x) & -F(x)]来说，其永为假，我们称这样的公式是**可驳的**。
+ 命题逻辑的几条**公理**：
    + X v X → X
    + X → X v Y
    + X v Y → Y v X
    + (X → Y) → (Z v X → Z v Y) 
    + (\(\forall\)x) → F(y)
    + F(y) → (\(\exists\)x)

> 基于上述的公理，存在如下两个规则：
>
> 1. 替换：在避免约束变量和自由变量相冲突的情况下，可以用一个公式
来替换一个命题变量；如果可以避免冲突，则约束变量和自由变量都可以改
变；可以使用公式来代替谓词。
2. 蕴涵：如果公式M为真，并且公式M → N为真，则N为真。
>
> 第二个规则称为演绎推理（modus ponens），它看上去是显而易见的，但是事实上，它必须是公理。你不能推导出它。
>
> 我们可以把任何从这**六条公理和两条规则**中推导出来的公式都称作定理。推导过程本身称为证明。证明得出的公式称为是可证明的。一条定理即为一个可证明的公式。这些规则的应用方式有两种：从公理开始，然后使用规则推导定理；或者从一个公式开始，使用规则把它转化成一个公理，这种情况下就可以证明这个公式是一个定理。

+ 希尔伯特将数学形式化，就像是把它归纳为符号操作的机械过程。
+ 数学公理化的主要内容就是：
    1. 建立一个体系内的基本公理，并由公理本身推导出体系内的所有定理，推论等。
    2. 建立并完善一套形式化符号系统，用于公理、定理的表示和演算。
    
> 第一点是目的，第二点是工具。而你也很容易发现，现在的计算机编程很大程度上受益于数学的公理化研究。

+ 函数概念源于数学。函数是把输入转换为输出的数学实体。输入称为函数的**参数**或**自变量**；输出称作函数的**值**或**因变量**。合法的输入称为函数的**定义域**，可能的结果输出值称为**值域**。

+ 计算机中就是使用有理数来近似表示实数的。比如123.456就表示为有理数(两个整数的相除)\(8 687 443 681 197 687/2^{46}\)，在实际操作中，只需要存储`8 687 443 681 197 687`和指数部分`46`两个整数部分。

+ 在Lambda表达式中，函数和变量经常互换角色。其关于整数的Lambda表示为如下`1->λfx.f(x)`、`2->λfx.f(f(x))`、`3->λfx.f(f(f(x)))`，`n->λfx.f(f(f...(x)...))`。其代表的意义就是**每个正整数的抽象表达式中都会增加对第一个自变量的嵌套**，这一定义本质上表明了正整数的**后继性**，基于此，可以定义基本的算术运算如下：
    + `+`  -> `λpgfx.p(f,g(f,x))`。
    + `-`  -> 
    + `*`  -> `λpgx.p(q(x))`。
    + `÷`  ->
    + `幂` -> `λmn.nm`, m的n次方。

> 将数字本身Lambda形式化的一个自然结果就是，关于数字的算术运算符均可以表述为一定形式的Lambda表达式。而且指数形式的Lambda表达式是最简单的。同时，作为程序员，我们会敏锐的意识到，“数据就是程序”以及“程序就是数据”是直达本质的表述。

+ 任意的**λ可定义函数**都是**可计算**的，并且每一个可计算函数是**一般递归函数**。即**递归函数 == 可计算函数 == λ可定义函数**。

+ 区别于物理学的“客观性”，数学是“人造宝石”还是“天然宝石”一直存在争论，这一问题的实质是，人类是“发明了”还是“发现了”那些数学知识和理论。

+ 图灵创造图灵机的初衷是为了一个特定的目的：证明对于一阶逻辑并不存在通用判定过程。

+ 如果一门计算机编程语言能够模拟图灵机，它就被称为是**图灵完备**的。

+ HTML/CSS等等不是图灵完备的，但大多数的主流编程语言(java/C/C++/C#等等)均是图灵完备的。图灵完备的语言之间可以相互模拟。

[mathjax]