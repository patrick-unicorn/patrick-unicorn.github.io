---
author: "patrick.unicorn"
date: "July 28, 2015"
output:
  html_document:
    css: ../../css/main.css
    highlight: null
    theme: null
---

Java线程中的锁和信号机制
===

- - -

## Thread

Java中基本的并发机制就是多线程。线程是程序执行的最小单位。多线程编程最困难的地方就在于处理**共享资源**的竞争性访问。

### Daemon

Java中线程分为守护线程（Daemon）和用户线程（User）。两者的区别如下：

+ 守护线程是为用户线程服务的，它的优先级为低。

+ 守护线程的生命周期依赖于外部的用户线程。

当JVM中的用户线程都结束后，系统会退出（守护线程自然也会被终结）。通常在守护线程中，不应放入过多的用户逻辑，因为守护线程的结束依赖于外部用户线程生命周期，因此，无法预知其执行的时机，有可能造成潜在的错误。

```
Thread t = new Thread(...);
// 必须在线程启动之前设置
t.setDaemon(true);
t.start();
```

## Monitor

每个对象都伴随一个监控器对象（monitor），该对象的作用是

## Synchronized & Wait/Notify

### Synchronized

### Wait/Notify

+ wait

+ notify[All]

**关键点：**

+ 均定义在Object基类上

+ 是一组协作方法，必须配对使用

+ 当前线程必须持有**协调对象**的Monitor时，才能调用其方法

```
class Ex {
    public static void main(String[] args) {
		Object L = new Object();
		try {
		    // 因为此处线程并没有持有对象L的monitor，所以
		    // 会导致java.lang.IllegalMonitorStateException
			L.wait(); 
			
			// 正确的方式
			synchronized(L) {
			    L.wait();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```
<blockquote>
为什么必须持有**协调对象**monitor，才可以调用其wait/notify[all]?

线程之间通过对象的wait/notify[all]方法进行协作，那么，该对象必然是“共享资源”，面临竞争性使用，因此，获取该对象的Monitor就理所当然成为使用其方法wait/notify[All]的先决条件了。
</blockquote>

### Join

`Thread#Join`方法其实就是对`Object#wait`方法的一个包装：

```
public final synchronized void join(long millis)
```

只不过此时的协调对象是Thread本身（`this`)，方法签名中的`synchronized`说明了这点。

## Lock & Condition

在Java1.5之前，多线程编程只能基于上述的**Syncrhonized & Wait/Notify**机制，其具有明显的弊端：

+ 性能低

`Synchronized`底层的实现机制（*JDK1.5以前*）导致锁的性能成本太高。

+ 不灵活

<blockquote>
1. `Synchronized`不能跨方法使用，即不能在A方法中加锁，而在B方法中解锁。
2. `Synchronized`加锁会导致不可中断的阻塞。
</blockquote>

+ 不完备

<blockquote>
1. 从上面的表述中，我们可以看到**锁**和**协调对象**之间是具有明显关联的。而**Syncrhonized & Wait/Notify**机制中，对这一关联并未有显著的设定，设计上并不完备。
2. **Wait/Notify**的协作机制过于单调，无法直接完成复杂的线程协作。
</blockquote>

### Lock

#### Advantage

### Condition

#### Advantage