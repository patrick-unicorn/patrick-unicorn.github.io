---
author: "patrick.unicorn"
date: "July 28, 2015"
output:
  html_document:
    css: ../../css/main.css
    highlight: null
    theme: null
---

Java线程中的锁和信号机制
===

- - -

## Thread

Java中基本的并发机制就是多线程。线程是程序执行的最小单位。多线程编程最困难的地方就在于处理**共享资源**的竞争性访问。

### Daemon

Java中线程分为守护线程（Daemon）和用户线程（User）。两者的区别如下：

+ 守护线程是为用户线程服务的，它的优先级为低。

+ 守护线程的生命周期依赖于外部的用户线程。

当JVM中的用户线程都结束后，系统会退出（守护线程自然也会被终结）。通常在守护线程中，不应放入过多的用户逻辑，因为守护线程的结束依赖于外部用户线程生命周期，因此，无法预知其执行的时机，有可能造成潜在的错误。

```
Thread t = new Thread(...);
// 必须在线程启动之前设置
t.setDaemon(true);
t.start();
```

## Monitor

每个对象都伴随一个监控器对象（monitor），该对象的作用是

## Synchronized & Wait/Notify

### Synchronized

### Wait/Notify

+ wait

+ notify[All]

**关键点：**

+ 均定义在Object基类上

+ 是一组协作方法，必须配对使用

+ 当前线程必须持有对象的Monitor时，才能调用

```
class Ex {
    public static void main(String[] args) {
		Object L = new Object();
		try {
		    // 因为此处线程并没有持有对象L的monitor，所以
		    // 会导致java.lang.IllegalMonitorStateException
			L.wait(); 
			
			// 正确的方式
			synchronized(L) {
			    L.wait();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```
<blockquote>
为什么必须持有monitor，才可以调用wait/notify[all]?

线程之间通过对象的wait/notify[all]方法进行协作，那么，该对象必然是“共享资源”，面临竞争性使用，因此，获取该对象的Monitor就理所当然成为使用其方法wait/notify[All]的先决条件了。
</blockquote>

### Thread Join

## Lock & Condition

### Lock

#### Advantage

### Condition

#### Advantage